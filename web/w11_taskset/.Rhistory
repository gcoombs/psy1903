dir.create("data/raw", recrusive = TRUE)
dir.create("data/raw", recursive = TRUE)
dir.create("data/cleaned", recursive = TRUE)
dir.create("scripts", recursive = TRUE)
dir.create("reports", recursive = TRUE)
file.create("scripts/score_questionnaire.R")
file.create("scripts/compute_rt_if_missing.R")
file.create("scripts/summarize_behavior.R")
file.create("scripts/process_participant.R")
file.create("reports/w11_taskset.qmd")
source("scripts/import_est_from_osf.R")
library(readr)
data <- read_csv("data/raw/est-experiment-2025-11-05-09-04-45.csv")
View(data)
# Ensure all expected column names are there
if (!all(c("block","condition","color","word","rt","response","correct",
"stim_onset_ms","resp_time_ms") %in% names(data)) ||
!any(c("trial_type", "trialType") %in% names(data))) {
stop("Input data frame is missing required columns.")
}
## Check if rt column is numeric
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
warning("'rt' column was not numeric. Coerced with as.numeric().")
}
## Change correct column to logical
if (!is.logical(data$correct)) {
data$correct <- as.logical(data$correct)
}
## Filter out unreasonable reaction times (keep 300–900 ms)
data_filtered    <- data[data$rt >= rt_min &
data$rt <= rt_max, ]
rt_min = 300; rt_max = 900
## Filter out unreasonable reaction times (keep 300–900 ms)
data_filtered    <- data[data$rt >= rt_min &
data$rt <= rt_max, ]
## Calcluate mean accuracy
mean_accuracy <- mean(data_filtered$correct, na.rm = TRUE)
## Calculate mean reaction time for only correct trials
mean_rt_correct <- mean(data_filtered[data$correct == TRUE, ]$rt, na.rm = TRUE)
str(data)
## Calculate mean reaction time for only correct trials
mean_rt_correct <- mean(data_filtered[data_filtered$correct == TRUE, ]$rt, na.rm = TRUE)
## Extra Credit: Calculate mean RT by condition
emo_means <- tapply(data_filtered[data_filtered$correct == TRUE, ]$rt,
data_filtered$condition,
FUN = mean, na.rm = TRUE)
## Extra Credit: Calculate mean RT by condition
emo_means <- tapply(data_filtered[data_filtered$correct == TRUE, ]$rt,
data_filtered[data_filtered$correct == TRUE, ]$condition,
FUN = mean, na.rm = TRUE)
emo_means
emo_means["negative"]
unname(emo_means["negative"])
## Create data frame
participant_summary <- data.frame(
mean_accuracy    = mean_accuracy,
mean_rt_correct  = mean_rt_correct,
mean_rt_negative = unname(emo_means["negative"]),
mean_rt_positive = unname(emo_means["positive"]),
mean_rt_neutral = unname(emo_means["neutral"]),
stringsAsFactors   = FALSE,
row.names = FALSE
)
participant_summary
## Create data frame
participant_summary <- data.frame(
mean_accuracy    = mean_accuracy,
mean_rt_correct  = mean_rt_correct,
mean_rt_negative = unname(emo_means["negative"]),
mean_rt_positive = unname(emo_means["positive"]),
mean_rt_neutral = unname(emo_means["neutral"]),
stringsAsFactors   = FALSE,
row.names = TRUE
)
participant_summary
## Create data frame
participant_summary <- data.frame(
mean_accuracy    = mean_accuracy,
mean_rt_correct  = mean_rt_correct,
mean_rt_negative = unname(emo_means["negative"]),
mean_rt_positive = unname(emo_means["positive"]),
mean_rt_neutral = unname(emo_means["neutral"]),
stringsAsFactors   = FALSE
)
participant_summary
esq_score <- score_questionnaire(
json_string = data[data$trialType == "questionnaire", "response"],
reverse = c(2, 4, 7),
scale_min = 0L,
scale_max = 4L
)
#### Q6.1 Score ESQ-9 ----------------------------------------------------------
## Purpose: Take a JSON string from the questionnaire row and return a single score.
## Scale: jsPsychSurveyLikert default 0–4. Reverse items: 2, 5, 9.
## Example input: participant_data[participant_data$trialType == "questionnaire", "response"]
score_questionnaire <- function(json_string,
reverse = c(2, 5, 9),
scale_min = 0L,
scale_max = 4L) {
# If the JSON string is missing or empty, return a numeric NA
if (is.null(json_string) || is.na(json_string) || !nzchar(json_string)) {
return(NA_real_)
}
## 1) Parse the JSON string into an R object
responses <- fromJSON(json_string)
## 2) Flatten and convert to numeric
responses <- as.numeric(unlist(responses))
# If reverse is provided, it must reference valid item positions
if (length(reverse) > 0) {
if (any(reverse < 1 | reverse > length(responses))) {
stop("One or more 'reverse' item indices are out of range for this questionnaire response.")
}
}
## 3) Reverse-score the specified items
if (length(reverse) > 0) {
responses[reverse] <- (scale_max + scale_min) - responses[reverse]
}
## 5) Compute the final score
sum_score <- sum(responses, na.rm = TRUE)
return(sum_score)
}
#### Score Behavioral Data ------------------------------------
summarize_behavior <- function(data, rt_min = 300, rt_max = 900) {
# Ensure all expected column names are there
if (!all(c("block","condition","color","word","rt","response","correct",
"stim_onset_ms","resp_time_ms") %in% names(data)) ||
!any(c("trial_type", "trialType") %in% names(data))) {
stop("Input data frame is missing required columns.")
}
## Check if rt column is numeric
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
warning("'rt' column was not numeric. Coerced with as.numeric().")
}
## Change correct column to logical
if (!is.logical(data$correct)) {
data$correct <- as.logical(data$correct)
}
## Filter out unreasonable reaction times (keep 300–900 ms)
data_filtered    <- data[data$rt >= rt_min &
data$rt <= rt_max, ]
## Calcluate mean accuracy
mean_accuracy <- mean(data_filtered$correct, na.rm = TRUE)
## Calculate mean reaction time for only correct trials
mean_rt_correct <- mean(data_filtered[data_filtered$correct == TRUE, ]$rt, na.rm = TRUE)
## Extra Credit: Calculate mean RT by condition
emo_means <- tapply(data_filtered[data_filtered$correct == TRUE, ]$rt,
data_filtered[data_filtered$correct == TRUE, ]$condition,
FUN = mean, na.rm = TRUE)
## Create data frame
participant_summary <- data.frame(
mean_accuracy    = mean_accuracy,
mean_rt_correct  = mean_rt_correct,
mean_rt_negative = unname(emo_means["negative"]),
mean_rt_positive = unname(emo_means["positive"]),
mean_rt_neutral = unname(emo_means["neutral"]),
stringsAsFactors   = FALSE
)
# Accuracy 0..1
acc_cols <- c("mean_accuracy")
for (col in acc_cols) {
val <- participant_summary[[col]]
if (!is.na(val) && (val < 0 || val > 1)) {
warning(paste(col, "is outside [0, 1]. Check 'correct' coding."))
}
}
# Mean RTs within [rt_min, rt_max]
rt_cols <- c("mean_correct_rt", "mean_rt_negative", "mean_rt_positive", "mean_rt_neutral")
for (col in rt_cols) {
val <- participant_summary[[col]]
if (!is.na(val) && (val < rt_min || val > rt_max)) {
warning(paste(col, "is outside [", rt_min, ", ", rt_max, "]."))
}
}
return(participant_summary)
}
esq_score <- score_questionnaire(
json_string = data[data$trialType == "questionnaire", "response"],
reverse = c(2, 4, 7),
scale_min = 0L,
scale_max = 4L
)
View(data)
esq_score <- score_questionnaire(
json_string = data[data$trialType == "es_questionnaire", "response"],
reverse = c(2, 4, 7),
scale_min = 0L,
scale_max = 4L
)
data[data$trialType == "es_questionnaire", "response"]
fromJSON(data[data$trialType == "es_questionnaire", "response"])
fromJSON(as.character(data[data$trialType == "es_questionnaire", "response"]))
fromJSON(data[data$trialType == "es_questionnaire", "response"])
data[data$trialType == "es_questionnaire", "response"]
esq_score <- score_questionnaire(
json_string = data[data$trialType == "es_questionnaire", "response"],
reverse = c(2, 4, 7),
scale_min = 0L,
scale_max = 4L
)
#### Questionnaire score -----------------------------------------------------
json_string <- data$response[data$trialType == "es_questionnaire"]
#### Questionnaire score -----------------------------------------------------
json_string <- data$response[data$trialType == "es_questionnaire"]
#### Questionnaire score -----------------------------------------------------
json_string <- participant_data[participant_data$trialType == "es_questionnaire", "response"]
esq_score <- score_questionnaire(
json_string = json_string,
reverse = c(2, 4, 7),
scale_min = 0L,
scale_max = 4L
)
## Combine into a single-row participant summary
df_clean <- data.frame(
subject_id = subject_id,
esq_score = esq_score,
behavior = behavior
)
#### Load File and Extract ID ------------------------------------------------
## Derive a subject id from the filename (no extension)
subject_id <- sub("\\.csv$", "", basename(file_name))
subject_id <- "est-1"
#### Behavioral summary ------------------------------------------------------
## Filter and summarize behavioral data (300–900 ms)
behavior <- summarize_behavior(participant_data, rt_min = 300, rt_max = 900)
#### Behavioral summary ------------------------------------------------------
## Filter and summarize behavioral data (300–900 ms)
behavior <- summarize_behavior(data, rt_min = 300, rt_max = 900)
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("/scripts/process_participant.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/process_participant.R"))
source(here::here("scripts/compute_rt_if_missing.R"))
file_list <- list.files(
here::here("data", "raw"),
pattern = "^est-experiment-.*\\.csv$",
full.names = FALSE
)
file_list <- list.files(
here::here("data", "raw"),
pattern = "^est-experiment-.*\\.csv$",
full.names = FALSE
)
participant_rows <- lapply(file_list, process_participant)
if (!require("pacman")) {install.packages("pacman"); require("pacman")}
p_load("jsonlite", "ggplot2", "here")
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/process_participant.R"))
source(here::here("scripts/compute_rt_if_missing.R"))
file_list <- list.files(
here::here("data", "raw"),
pattern = "^est-experiment-.*\\.csv$",
full.names = FALSE
)
participant_rows <- lapply(file_list, process_participant)
study_level <- do.call(rbind, participant_rows)
study_level
names(data) <- gsub("^behavior\\.", "", names(data))
## Rename column names without behavior. prefix
names(study_level) <- gsub("^behavior\\.", "", names(study_level))
View(study_level)
round(mean(study_level$mean_rt_positive, na.rm = TRUE), 2)
round(mean(study_level$mean_rt_negative, na.rm = TRUE), 2)
round(mean(study_level$mean_rt_neutral, na.rm = TRUE), 2)
lapply(file_list, process_participant)
participant_rows <- lapply(file_list, process_participant)
str(participant_rows)
summary(participant_rows)
round(mean(study_level$accuracy, na.rm = TRUE), 2)
study_level$accuracy
